#!/bin/sh
#----------------------------------------------------------------------------
# /var/install/config.d/ssh.sh - configuration generator script for SSH
#
# Creation:     2002-11-06  jh
# Last Update:  $Id: ssh.sh 29270 2011-12-16 13:56:21Z jv $
#
#----------------------------------------------------------------------------


# For manual configuration of /etc/ssh/sshd_config
# set SSHD_MAN_CONFIG to 'yes'
SSHD_MAN_CONFIG='no'

pgmname=$0

# set variables
base_eiscfg=/etc/config.d/base
ssh_eiscfg=/etc/config.d/sshd
sshd_config_file=/etc/ssh/sshd_config
ssh_authorized_keys_file=/root/.ssh/authorized_keys
ssh_authorized_keys_file_tmp=/root/.ssh/authorized_keys_tmp.$$
certfile='/usr/local/ssl/certs/pure-ftpd.pem'

#-------------------------------------------------------------------------------
# create sshd_config file
#-------------------------------------------------------------------------------
create_sshd_config ()
{
    if [ "$SSHD_MAN_CONFIG" = 'yes' ]
    then
        echo "Attention: SSHD_MAN_CONFIG='yes' sshd configuration not changed"
        return
    fi

    if [ "$SSHD_USE_SSH1" = "yes" -a "$SSHD_USE_SSH2" = "yes" ]
    then
        prot_str='1,2'
    else
        if [ "$SSHD_USE_SSH1" = "yes" ]
        then
            prot_str='1'
        else
            prot_str='2'
        fi
    fi

    # set ssh allow groups
    if [ "$SSHD_ALLOW_GROUP_N" -gt "0" ]
    then
        tmp_str=''
        idx=1
        while [ "$idx" -le "$SSHD_ALLOW_GROUP_N" ]
        do
            eval name='$SSHD_ALLOW_GROUP_'$idx
            tmp_str="$tmp_str$name "
            idx=`expr $idx + 1`
        done
        str_allowgroups="AllowGroups $tmp_str"
    else
        str_allowgroups="#AllowGroups"
    fi

    # set ssh allow users
    if [ "$SSHD_ALLOW_USER_N" -gt "0" ]
    then
        tmp_str=''
        idx=1
        while [ "$idx" -le "$SSHD_ALLOW_USER_N" ]
        do
            eval name='$SSHD_ALLOW_USER_'$idx
            tmp_str="$tmp_str$name "
            idx=`expr $idx + 1`
        done
        str_allowusers="AllowUsers $tmp_str"
    else
        str_allowusers="#AllowUsers"
    fi

    # set ssh deny groups
    if [ "$SSHD_DENY_GROUP_N" -gt "0" ]
    then
        tmp_str=''
        idx=1
        while [ "$idx" -le "$SSHD_DENY_GROUP_N" ]
        do
            eval name='$SSHD_DENY_GROUP_'$idx
            tmp_str="$tmp_str$name "
            idx=`expr $idx + 1`
        done
        str_denygroups="DenyGroups $tmp_str"
    else
        str_denygroups="#DenyGroups"
    fi

    # set ssh deny users
    if [ "$SSHD_DENY_USER_N" -gt "0" ]
    then
        tmp_str=''
        idx=1
        while [ "$idx" -le "$SSHD_DENY_USER_N" ]
        do
            eval name='$SSHD_DENY_USER_'$idx
            tmp_str="$tmp_str$name "
            idx=`expr $idx + 1`
        done
            str_denyusers="DenyUsers $tmp_str"
    else
            str_denyusers="#DenyUsers"
    fi

    # enable sftp
    if [ "$SSHD_ENABLE_SFTP" = "yes" ]
    then
        str_usesftp="Subsystem sftp /usr/lib/ssh/sftp-server"
    else
        str_usesftp="#Subsystem sftp Subsystem sftp /usr/lib/ssh/sftp-server"
    fi


cat > $sshd_config_file << EOF
# -------------------------------------------------------------------------------
# sshd_config file generated by $pgmname
# Do not edit this file, edit $ssh_eiscfg
# Creation date: `date`
# -------------------------------------------------------------------------------

# What ports, IPs and protocols we listen for
Port $SSHD_PORT

#ListenAddress ::
#ListenAddress 0.0.0.0

# Use these options to restrict which interfaces/protocols sshd will bind to
Protocol $prot_str

$str_allowgroups
$str_allowusers
$str_denygroups
$str_denyusers


# The default requires explicit activation of protocol 1
#Protocol 2

# HostKey for protocol version 1
#HostKey /etc/ssh/ssh_host_key
# HostKeys for protocol version 2
HostKey /etc/ssh/ssh_host_rsa_key
HostKey /etc/ssh/ssh_host_dsa_key
HostKey /etc/ssh/ssh_host_ecdsa_key

# Lifetime and size of ephemeral version 1 server key
#KeyRegenerationInterval 3600
#ServerKeyBits $SSHD_SVR_KEYBITS

# Logging
# obsoletes QuietMode and FascistLogging
SyslogFacility AUTH
LogLevel $SSHD_LOGLEVEL

# Authentication:

LoginGraceTime 120
PermitRootLogin $SSHD_PERMITROOTLOGIN
StrictModes $SSHD_STRICTMODES
#MaxAuthTries 6
#MaxSessions 10

RSAAuthentication yes
PubkeyAuthentication yes
AuthorizedKeysFile %h/.ssh/authorized_keys

#AuthorizedPrincipalsFile none

# For this to work you will also need host keys in /etc/ssh_known_hosts
RhostsRSAAuthentication no
# similar for protocol version 2
HostbasedAuthentication no
# Change to yes if you don't trust ~/.ssh/known_hosts for
# RhostsRSAAuthentication and HostbasedAuthentication
#IgnoreUserKnownHosts no
# Don't read the user's ~/.rhosts and ~/.shosts files
IgnoreRhosts yes

# To disable tunneled clear text passwords, change to no here!
PasswordAuthentication ${SSHD_PASSWDAUTH}
PermitEmptyPasswords no

# Change to no to disable s/key passwords
ChallengeResponseAuthentication $SSHD_CH_RESPONSEAUTH

# Kerberos options
#KerberosAuthentication no
#KerberosOrLocalPasswd yes
#KerberosTicketCleanup yes
#KerberosGetAFSToken no

# GSSAPI options
#GSSAPIAuthentication no
#GSSAPICleanupCredentials yes

# Set this to 'yes' to enable PAM authentication, account processing,
# and session processing. If this is enabled, PAM authentication will
# be allowed through the ChallengeResponseAuthentication mechanism.
# Depending on your PAM configuration, this may bypass the setting of
# PasswordAuthentication, PermitEmptyPasswords, and
# "PermitRootLogin without-password". If you just want the PAM account and
# session checks to run without PAM authentication, then enable this but set
# ChallengeResponseAuthentication=no
#UsePAM $SSHD_USEPAM

#AllowAgentForwarding yes
#AllowTcpForwarding yes
#GatewayPorts no
X11Forwarding no
X11DisplayOffset 10
#X11UseLocalhost yes
PrintMotd yes
#PrintLastLog yes
TCPKeepAlive yes
#UseLogin no
UsePrivilegeSeparation $SSHD_ENABLE_PRIV_SEPARATION
#PermitUserEnvironment no
Compression $SSHD_COMPRESSION
ClientAliveInterval $SSHD_CLIENTALIVEINTERVAL
ClientAliveCountMax $SSHD_CLIENTALIVECOUNTMAX
UseDNS no
#PidFile /var/run/sshd.pid
MaxStartups $SSHD_MAX_STARTUPS
#PermitTunnel no
#ChrootDirectory none
#VersionAddendum none

# Allow client to pass locale environment variables
AcceptEnv LANG LC_*

# no default banner path
#Banner none

# sftp
$str_usesftp

EOF

    if [ "$SSHD_LISTEN_ADDR_N" -gt "0" ]
    then
        idx=1
        tmp_str=""
        echo "ListenAddress 127.0.0.1" >> $sshd_config_file
        while [ "$idx" -le "$SSHD_LISTEN_ADDR_N" ]
        do
            eval laddr='$SSHD_LISTEN_ADDR_'$idx
            if [ -z "$laddr" ]
            then
                echo "Empty Listenaddress SSHD_LISTEN_ADDR_$idx ignored"
            else
                # check number, substitution has to result in an empty string
                e_laddr=`echo "$laddr" | sed 's|[0-9]*||'`
                if [ -n "$e_laddr" ]
                then
                    echo "Invalid SSHD_LISTEN_ADDR_$idx ($laddr) ignored"
                else
                    eval ipaddr=\${IP_NET_${laddr}_IPADDR}
                    if [ -z "$ipaddr" ]
                    then
                        echo "Empty IP Address IP_NET_${laddr}_IPADDR ignored"
                    else
                        echo "ListenAddress $ipaddr " >> $sshd_config_file
                    fi
                fi
            fi
            idx=`expr ${idx} + 1`
        done
    fi

}

#-------------------------------------------------------------------------------
# create authorized_keys file and add public keys
#-------------------------------------------------------------------------------
create_ssh_authorized_keys ()
{
    echo "Creating authorized_keys file ..."

    mkdir -p /root/.ssh

    # check first
    idx=1
    while [ "$idx" -le "$SSHD_PUBLIC_KEY_N" ]
    do
        eval key='$SSHD_PUBLIC_KEY_'$idx

        if [ -z "$key" ]
        then
            echo "Empty SSHD_PUBLIC_KEY_$idx ignored"
        fi

        if [ "${key:0:1}" = '/' ]
        then
            if [ ! -r "$key" ]
            then
                echo "SSHD_PUBLIC_KEY_$idx File $key does not exist or is not readable"
            fi
        fi
        idx=`expr $idx + 1`
    done


    # create temporary file
    (
        idx=1
        while [ "$idx" -le "$SSHD_PUBLIC_KEY_N" ]
        do
            eval key='$SSHD_PUBLIC_KEY_'$idx

            if [ -n "$key" ]
            then
               if [ "${key:0:1}" = '/' ]
               then
                  if [ -r "$key" ]
                  then
                     cat "$key"
                     # add newline
                     echo
                  fi
               else
                  echo "$key"
                  # add newline
                  echo
               fi
            fi

            idx=`expr $idx + 1`
        done
    ) > $ssh_authorized_keys_file_tmp

    # copy temporary file to final file
    # omit empty lines
    grep -v '^$' $ssh_authorized_keys_file_tmp > $ssh_authorized_keys_file

    rm -f $ssh_authorized_keys_file_tmp

}

#-------------------------------------------------------------------------------
# delete public keys from authorized_keys file
#-------------------------------------------------------------------------------
delete_ssh_authorized_keys ()
{

    if [ -f $ssh_authorized_keys_file ]
    then
        echo "Deleting authorized_keys file ..."
        rm -f $ssh_authorized_keys_file
    fi
}

#-------------------------------------------------------------------------------
# create privilege separation environment
#-------------------------------------------------------------------------------
create_ssh_privsep_env ()
{
    [ "$MMODE" = 'detailed' ] && echo "Creating sshd user account ..."

    # add sshd group
    grep "^sshd:" /etc/group > /dev/null

    if [ "$?" != "0" ]
    then
        # 1-group 2-gid
        /var/install/bin/add-group "sshd" "65" > /dev/null
    fi

    # add sshd user
    /bin/grep "^sshd:" /etc/passwd > /dev/null

    if [ "$?" != "0" ]
    then
        # 1-user 2-password 3-uid 4-gid 5-name 6-home 7-shell
        /var/install/bin/add-user "sshd" "*" "71" "65" "Privilege separation user sshd" "/var/empty" "/bin/false" > /dev/null
    fi

    [ "$MMODE" = 'detailed' ] && echo "Setting access rights ..."

    # setting access rights
    /bin/chown root:root /var/empty
    /bin/chmod 755 /var/empty
}

#-------------------------------------------------------------------------------
# delete privilege separation environment
#-------------------------------------------------------------------------------
delete_ssh_privsep_env ()
{
    /bin/grep "^sshd:" /etc/passwd > /dev/null

    # remove sshd user
    if [ "$?" = 0 ]
    then
        # user exists, delete it
        [ "$MMODE" = 'detailed' ] && echo "Deleting sshd user account ..."
        # parameter: -f (force) [user][remove homedir yes/no]
        /var/install/bin/remove-user -f "sshd" "yes" > /dev/null
        # remove sshd group
        echo -e "sshd\n"|/var/install/bin/remove-group > /dev/null
        # home directory has been removed by user removal
    fi

}




#-------------------------------------------------------------------------------
# check certificate file
#-------------------------------------------------------------------------------
check_certfile ()
{
    if [ "$FTP_TLS" != '0' ]
    then
        if [ ! -f $certfile ]
        then
            echo "support for SSL/TLS is enabled, but the"
            echo "certificate $certfile does not exist"
        fi
    fi
}

#===============================================================================
# main
#===============================================================================


# read configuration
. $ssh_eiscfg
. $base_eiscfg



create_sshd_config

if [ "$SSHD_PUBLIC_KEY_N" -gt "0" ]
then
    create_ssh_authorized_keys
else
    delete_ssh_authorized_keys
fi

if [ "$SSHD_ENABLE_PRIV_SEPARATION" = "yes" ]
then
    # don't create sshd user or group on time
    # create_ssh_privsep_env
    true
fi

#===============================================================================
exit 0
