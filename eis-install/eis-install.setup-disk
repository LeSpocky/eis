#!/bin/bash
# alpine linux - eisfair-ng version

PREFIX=
. "$PREFIX/lib/libalpine.sh"

MBR=${MBR:-"/usr/share/syslinux/mbr.bin"}
ROOTFS=${ROOTFS:-ext4}
BOOTFS=${BOOTFS:-ext4}
VARFS=${VARFS:-ext4}

PKEYBLAYOUT="de"
PKEYBVARIANT="de-latin1"
PNETIPSTATIC="1"
PIPADDRESS="192.168.1.2"
PNETMASK="255.255.255.0"
PGATEWAY="192.168.1.1"
PHOSTNAME="eis"
PDOMAIN="eisfair.home"
PDNSSERVER="192.168.1.1"
PTIMEZONE="CET-1CEST,M3.5.0,M10.5.0/3"
PPASSWORD="eis"
USE_RAID=""
SWAP_SIZE="0"

in_list() {
	local i="$1"
	shift
	while [ $# -gt 0 ]; do
		[ "$i" = "$1" ] && return 0
		shift
	done
	return 1
}

all_in_list() {
	local needle="$1"
	local i
	[ -z "$needle" ] && return 1
	shift
	for i in $needle; do
		in_list "$i" $@ || return 1
	done
	return 0
}

# wrapper to only show given device
_blkid() {
	blkid | grep "^$1:"
}

# if given device have an UUID display it, otherwise return the device
uuid_or_device() {
	local i=
	case "$1" in
		/dev/md*) echo "$1" && return 0;;
	esac
	for i in $(_blkid "$1"); do
		case "$i" in
			UUID=*) eval $i;;
		esac
	done
	if [ -n "$UUID" ]; then
		echo "UUID=$UUID"
	else
		echo "$1"
	fi
}

# generate an fstab from a given mountpoint. Convert to UUID if possible
enumerate_fstab() {
	local fs_spec= fs_file= fs_vfstype= fs_mntops= fs_freq= fs_passno=
	awk "\$2 ~ /^\/mnt(\/|\$)/ {print \$0}" /proc/mounts | \
		sed "s:/mnt:/:g; s: :\t:g" | sed 's:/\+:/:g' | \
		while read fs_spec fs_file fs_vfstype fs_mntops fs_freq fs_passno; do
			echo -e "$(uuid_or_device $fs_spec)\t${fs_file}\t${fs_vfstype}\t${fs_mntops} ${fs_freq} ${fs_passno}"
		done
}

is_vmware() {
	grep -q VMware /proc/scsi/scsi 2>/dev/null \
		|| grep -q VMware /proc/ide/hd*/model 2>/dev/null
}

# return true (0) if given device is lvm
is_lvm() {
	lvs "$1" >/dev/null 2>&1
}

# Find the disk device from given partition
disk_from_part() {
	# we need convert cciss/c0d0* cciss!c0d0*...
	local i= part=$(echo ${1#/dev/} | sed 's:/:!:g')
	for i in /sys/block/*/$part; do
		i=${i%/*}
		# ...and back from cciss!c0d0 to cciss/c0d0
		if [ -b "/dev/${i##*/}" ]; then
			echo "/dev/${i##*/}" | sed 's:!:/:g'
			return 0
		fi
	done
	return 1
}

unpack_apkovl() {
	local ovl="$1"
	local dest="$2"
	local suffix=${ovl##*.}
	local i
	ovlfiles=/tmp/ovlfiles
	if [ "$suffix" = "gz" ]; then
		tar -C "$dest" --numeric-owner -zxvf "$ovl" > $ovlfiles
		return 0 
	fi

	apk add --quiet openssl

	if ! openssl list-cipher-commands | grep "^$suffix$" > /dev/null; then
		errstr="Cipher $suffix is not supported"
		return 1
	fi
	local count=0
	# beep
	echo -e "\007"
	while [ $count -lt 3 ]; do
		openssl enc -d -$suffix -in "$ovl" | tar --numeric-owner \
			-C "$dest" -zxv >$ovlfiles 2>/dev/null && return 0
		count=$(( $count + 1 ))
	done
	ovlfiles=
	return 1
}

# find filesystem of given mounted dir
find_mount_fs() {
	local mount_point="$1"
	awk "\$2 == \"$mount_point\" {print \$3}" /proc/mounts | tail -n 1
}

# find device for given mounted dir
find_mount_dev() {
	awk "\$2 == \"/mnt\" { print \$1 }" /proc/mounts | tail -n 1
}

supported_boot_fs() {
	local supported="ext2 ext3 ext4 btrfs"
	local fs=
	for fs in $supported; do
		[ "$fs" = "$1" ] && return 0
	done
	echo "$1 is not supported. Only supported are: $supported" >&2
	return 1
}

find_volume_group() {
	local lv=${1##*/}
	lvs --noheadings "$1" | awk "\$1 == \"$lv\" {print \$2}"
}

find_pvs_in_vg() {
	local vg="$1"
	pvs --noheadings | awk "\$2 == \"$vg\" {print \$1}"
}

# echo current grsecurity option and set new
set_grsec() {
	local key="$1" value="$2"
	if ! [ -e /proc/sys/kernel/grsecurity/$key ]; then
		return 0
	fi
	cat /proc/sys/kernel/grsecurity/$key
	echo $value > /proc/sys/kernel/grsecurity/$key
}

init_chroot_mounts() {
	local mnt="$1" i=
	for i in proc dev; do
		mkdir -p "$mnt"/$i
		mount --bind /$i "$mnt"/$i
	done
}

cleanup_chroot_mounts() {
	local mnt="$1" i=
	for i in proc dev; do
		umount "$mnt"/$i
	done
}

install_mounted_root() {
	local mnt_boot= boot_fs= root_fs=
	local initfs_features="ata base ide scsi usb virtio"
	local pvs= dev= rootdev= bootdev= extlinux_raidopt= root= modules=
	local kernel_opts="quiet"
	local raidpkg=

	rootdev=$(find_mount_dev /mnt)
	if [ -z "$rootdev" ]; then
		echo "/mnt does not seem to be a mount point" >&2
		return 1
	fi
	root_fs=$(find_mount_fs /mnt)
	initfs_features="$initfs_features $root_fs"

	if is_lvm "$rootdev"; then
		initfs_features="$initfs_features lvm"
		local vg=$(find_volume_group "$rootdev")
		pvs=$(find_pvs_in_vg $vg)
	fi


	bootdev=$(find_mount_dev /mnt/boot)
	if [ -z "$bootdev" ]; then
		bootdev=$rootdev
		mnt_boot=/mnt
	else
		mnt_boot=/mnt/boot
	fi
	boot_fs=$(find_mount_fs "$mnt_boot")
	supported_boot_fs "$boot_fs" || return 1

	# Check if we boot from raid so we can pass proper option to
	# extlinux later.
	if [ -e "/sys/block/${bootdev#/dev/}/md" ]; then
		extlinux_raidopt="--raid"
	fi

	# check if our root is on raid so we can feed mkinitfs and
	# update-exlinux.conf with the proper kernel module params
	for dev in $rootdev $pvs; do
		[ -e "/sys/block/${dev#/dev/}/md" ] || continue

		local md=${dev#/dev/}
		initfs_features="${initfs_features% raid} raid"
		local level=$(cat /sys/block/$md/md/level)
		case "$level" in
			raid1) raidmod="${raidmod%,raid1},raid1";;
			raid[456]) raidmod="${raidmod%,raid456},raid456";;
		esac
	done

	# check if we need hardware raid drivers
	case $rootdev in
		/dev/cciss/*)
			initfs_features="${initfs_features% raid} raid"
			;;
	esac

	if [ -n "$VERBOSE" ]; then
		echo "Root device:     $rootdev"
		echo "Root filesystem: $root_fs"
		echo "Boot device:     $bootdev"
		echo "Boot filesystem: $boot_fs"
	fi

	if [ -z "$APKOVL" ]; then
		ovlfiles=/tmp/ovlfiles
		lbu package - | tar -C /mnt -zxv > "$ovlfiles"
	else
		echo "Restoring backup from $APKOVL to $rootdev..."
		unpack_apkovl "$APKOVL" /mnt || return 1
	fi

	# generate mkinitfs.conf
	mkdir -p /mnt/etc/mkinitfs/files.d
	echo "features=\"$initfs_features\"" > /mnt/etc/mkinitfs/mkinitfs.conf
	if [ -n "$raidmod" ]; then
		echo "/sbin/mdadm" > /mnt/etc/mkinitfs/files.d/raid
		echo "/etc/mdadm.conf" >> /mnt/etc/mkinitfs/files.d/raid
	fi

	# generate update-extlinux.conf
	root=$(uuid_or_device $rootdev)
	if is_vmware; then
		kernel_opts="pax_nouderef $kernel_opts"
	fi
	modules="sd-mod,usb-storage,${root_fs}${raidmod}"
	sed -e "s:^root=.*:root=$root:" \
		-e "s:^default_kernel_opts=.*:default_kernel_opts=\"$kernel_opts\":" \
		-e "s:^modules=.*:modules=$modules:" \
		/etc/update-extlinux.conf > /mnt/etc/update-extlinux.conf
	if [ "$(rc --sys)" = "XEN0" ]; then
		sed -i -e "s:^default=.*:default=xen-grsec:" \
			/mnt/etc/update-extlinux.conf
	fi

	# generate the fstab
	enumerate_fstab /mnt > /mnt/etc/fstab
	if [ -n "$SWAP_DEVICE" ]; then
		echo -e "${SWAP_DEVICE}\tswap\tswap\tdefaults\t0 0" \
			>> /mnt/etc/fstab
	fi
	cat >>/mnt/etc/fstab <<EOF
/dev/cdrom	/media/cdrom	iso9660	noauto,ro 0 0
/dev/fd0	/media/floppy	vfat	noauto	0 0
/dev/usbdisk	/media/usb	vfat	noauto	0 0
EOF

	# remove the installed db in case its there so we force re-install
	rm -f /mnt/var/lib/apk/installed /mnt/lib/apk/db/installed
	echo "Installing system on $rootdev:"
	extlinux $extlinux_raidopt --install /mnt/boot

	# apk reads config from target root so we need to copy the config
	mkdir -p /mnt/etc/apk/keys/
	cp /etc/apk/keys/* /mnt/etc/apk/keys/

	local apkflags="--initdb --update-cache --clean-protected"
	[ -n "$USE_RAID" ] && raidpkg="mdadm"
	pkgs="alpine-base linux-$KERNEL_FLAVOR $raidpkg acct bash dhcpcd e2fsprogs nano openssh libeventlog libcui fcron syslog-ng logrotate cuimenu-bin cuimenu syslinux"
	if [ "$(rc --sys)" = "XEN0" ]; then
		pkgs="$pkgs xen-hypervisor"
	fi
	local repos=$(sed -e 's/\#.*//' /etc/apk/repositories)
	local repoflags=
	for i in $repos; do
		repoflags="$repoflags --repository $i"
	done

	chroot_caps=$(set_grsec chroot_caps 0)
	init_chroot_mounts /mnt
	apk add --root /mnt $apkflags --overlay-from-stdin \
		$repoflags $pkgs <$ovlfiles || return 1
	cleanup_chroot_mounts /mnt
	set_grsec chroot_caps $chroot_caps >/dev/null
	return 0
}

unmount_partitions() {
	local mnt="$1"

	# unmount the partitions
	umount $(awk '{print $2}' /proc/mounts | egrep "^$mnt(/|\$)" | sort -r)
}


has_mounted_part() {
	local p
	local sysfsdev=$(echo ${1#/dev/} | sed 's:/:!:g')
	# parse /proc/mounts for mounted devices
	for p in $(awk '$1 ~ /^\/dev\// {gsub("/dev/", "", $1); gsub("/", "!", $1); print $1}' \
			/proc/mounts); do
		[ "$p" = "$sysfsdev" ] && return 0
		[ -e /sys/block/$sysfsdev/$p ] && return 0
	done
	return 1
}

has_holders() {
	local i
	# check if device is used by any md devices
	for i in $1/holders/* $1/*/holders/*; do
		[ -e "$i" ] && return 0
	done
	return 1
}

is_available_disk() {
	local dev=$1
	local b=$(echo $p | sed 's:/:!:g')

	# check if its a "root" block device and not a partition
	[ -e /sys/block/$b ] || return 1
	
	# check so it does not have mounted partitions
	has_mounted_part $dev && return 1

	# check so its not part of an md setup
	if has_holders /sys/block/$b; then
		[ -n "$USE_RAID" ] && echo "Warning: $dev is part of a running raid" >&2
		return 1
	fi

	# check so its not an md device
	[ -e /sys/block/$b/md ] && return 1

	return 0
}

find_disks() {
	local p=
	for p in $(awk '$1 ~ /[0-9]+/ {print $4}' /proc/partitions); do
		is_available_disk $p && echo -n " $p"
	done
}

stop_all_raid() {
	local rd
	for rd in /dev/md*; do
		[ -b $rd ] && mdadm --stop $rd
	done
}

# install needed programs
init_progs() {
	local raidpkg=
	[ -n "$USE_RAID" ] && raidpkg="mdadm"
	apk add --quiet sfdisk e2fsprogs lvm2 $raidpkg syslinux $@
}

show_disk_info() {
	local disk= vendor= model= d= size=
	for disk in $@; do
		local dev=${disk#/dev/}
		d=$(echo $dev | sed 's:/:!:g')
		vendor=$(cat /sys/block/$d/device/vendor 2>/dev/null)
		model=$(cat /sys/block/$d/device/model 2>/dev/null)
		size=$(awk '{gb = ($1 * 512)/1000000000; printf "%.1f GB\n", gb}' /sys/block/$d/size 2>/dev/null)
		echo "  $dev	($size $vendor $model)"
	done
}

# setup partitions on given disk dev in $1.
# usage: setup_partitions <diskdev> size1,type1 [size2,type2 ...] 
setup_partitions() {
	local diskdev="$1"
	shift

	echo "Initializing partitions on $diskdev..."

	# new disks does not have an DOS signature in sector 0
	# this makes sfdisk complain. We can workaround this by letting
	# fdisk create that DOS signature, by just do a "w", a write.
	# http://bugs.alpinelinux.org/issues/show/145
	echo "w" | fdisk $diskdev >/dev/null

	# fix the MBR while here so extlinux can boot
	cat "$MBR" > $diskdev

	local start=0
	local line=
	# create new partitions
	(
		for line in "$@"; do
			echo "$start,$line"
			start=
		done
	) | sfdisk -q -L -uM $diskdev >/dev/null || return 1

	# create device nodes if not exist
	mdev -s
}

# find the bootable partition on given disk
find_boot_partition() {
	sfdisk -d $1 | awk '/bootable/ {print $1}'
}

# find the partition(s) for LVM
# this is not marked as bootable and is type 8e
find_lvm_partition() {
	local type=8e
	sfdisk -d $1 | grep -v bootable | awk "/Id=$type/ {print \$1}"
}

# set up optional raid and create filesystem on boot device.
setup_boot_dev() {
	local disk= bootdev=
	local part=$(for disk in $@; do find_boot_partition $disk; done)
	set -- $part
	bootdev=$1
	[ -z "$bootdev" ] && return 1
	echo "Creating file systems..."
	if [ -n "$USE_RAID" ]; then
		local missing=
		local num=$#
		if [ $# -eq 1 ]; then
			missing="missing"
			num=2
		fi
		# we only use raid level 1 for boot devices
		mdadm --create /dev/md0 --bitmap=internal --level=1 --raid-devices=$num \
			--metadata=0.90 --quiet --run $@ $missing || return 1
		bootdev=/dev/md0
	fi
	mkfs.$BOOTFS -q $bootdev
	BOOT_DEV="$bootdev"
}

# $1 = index
# $2 = partition type
# $3... = disk devices
find_nth_non_boot_parts() {
	local idx=$1
	local id=$2
	local disk=
	shift
	shift
	for disk in $@; do
		sfdisk -d $disk | grep -v bootable \
			| awk "/Id=$id/ { i++; if (i==$idx) print \$1 }"
	done
}

setup_non_boot_raid_dev() {
	local md_dev=$1
	local idx=${md_dev#/dev/md}
	shift
	local level=1
	local missing=
	local raid_parts=$(find_nth_non_boot_parts $idx "fd" $@)
	set -- $raid_parts
	# how many disks do we have?
	case $# in
		0) echo "No Raid partitions found" >&2; return 1;;
		1) level=1; missing="missing"; num=2;;
		2) level=1; missing=  ; num=2;;
		*) level=5; missing=  ; num=$#;;
	esac
	mdadm --create /dev/md$idx --bitmap=internal --level=$level \
		--raid-devices=$num --quiet --run $@ $missing || return 1
}

# setup device for lvm, create raid array if needed
setup_lvm_volume_group() {
	local vgname="$1"
	shift
	local lvmdev=

	if [ -n "$USE_RAID" ]; then
		setup_non_boot_raid_dev /dev/md1 $@ || return 1
		lvmdev=/dev/md1
	else	
		lvmdev=$(find_lvm_partition $1)
	fi

	# be quiet on success
	local errmsg=$(dd if=/dev/zero of=$lvmdev bs=1k count=1 2>&1) \
		|| echo "$errmsg"
	pvcreate --quiet $lvmdev \
		&& vgcreate --quiet $vgname $lvmdev >/dev/null
}

# set up swap on given device(s)
setup_swap_dev() {
	local swap_dev=
	sed -i -e '/swap/d' /etc/fstab
	for swap_dev in "$@"; do
		mkswap $swap_dev >/dev/null
		echo -e "$swap_dev\tswap\t\tswap\tdefaults 0 0" >> /etc/fstab
	done
	SWAP_DEVICE="$(uuid_or_device $swap_dev)"
	swapon -a
	rc-update --quiet add swap boot
}

# setup and enable swap on given volumegroup if needed
setup_lvm_swap() {
	local vgname="$1"
	local swapname=lv_swap
	if [ -z "$SWAP_SIZE" ] || [ "$SWAP_SIZE" -eq 0 ]; then
		return
	fi
	lvcreate --quiet -n $swapname -L ${SWAP_SIZE}MB $vgname
	setup_swap_dev /dev/$vgname/$swapname
}

# set up /var on given device
setup_var() {
	local var_dev="$1"
	local varfs=${VARFS}
	echo "Creating file systems..."
	mkfs.$varfs -q $var_dev >/dev/null || return 1
	sed -i -e '/[[:space:]]\/var[[:space:]]/d' /etc/fstab
	echo -e "${var_dev}\t/var\t\t${varfs}\tdefaults 1 2" >> /etc/fstab

	mv /var /.var
	mkdir /var
	mount /var
	mv /.var/* /var/
	rmdir /.var

	/etc/init.d/syslog --quiet restart
	setup_mdadm_conf
}

setup_mdadm_conf() {
	local mods= mod=
	if [ -n "$USE_RAID" ]; then
		mdadm --detail --scan > /etc/mdadm.conf
		rc-update --quiet add mdadm-raid boot
		mods=$(awk '/^raid/ {print $1}' /proc/modules)
		for mod in $mods; do
			if ! grep -q "^$mod" /etc/modules; then
				echo $mod >> /etc/modules
			fi
		done
	fi
}


# set eisfair configuration
set_eis_configvar() {
	local par="$1"
	local val="$2"
	if ! grep -q "$par" /mnt/etc/config.d/base 2>/dev/null
	then
		echo "${par}='${val}'" >> /mnt/etc/config.d/base
	else
		sed -i -e "s/${par}=.*/${par}='${val}'/" /mnt/etc/config.d/base
	fi
}


rc_update() {
	local svc="$1"
	local level="$2"
	ln -sf /etc/init.d/$svc /mnt/etc/runlevels/${level}/$svc
}


setup_keymap() {
	if [ -n "$PKEYBVARIANT" ] ; then
		mkdir -p /mnt/etc/keymap
		mkdir -p /mnt/etc/conf.d/
		if gzip -9 -c "/usr/share/bkeymaps/$PKEYBLAYOUT/$PKEYBVARIANT.bmap" > "/mnt/etc/keymap/$PKEYBVARIANT.bmap.gz" ; then
			sed -i -e "s/^keymap=.*/keymap=\"${PKEYBLAYOUT}\"/" /mnt/etc/conf.d/keymaps
			sed -i '/^KEYMAP=/d' /etc/conf.d/keymaps
			echo "KEYMAP=/etc/keymap/${PKEYBVARIANT}.bmap.gz" >> /mnt/etc/conf.d/keymaps 
			set_eis_configvar KEYMAP "$PKEYBVARIANT" 
			rc_update keymaps boot
		fi
	fi
}

# network base configuration
setup_network() {
	{
	echo "auto lo"
	echo "iface lo inet loopback"
	echo ""
	echo "auto eth0"
	} >/mnt/etc/network/interfaces
	if [ "$PNETIPSTATIC" = "0" ] ; then
		echo "iface eth0 inet dhcp" >> /mnt/etc/network/interfaces
		set_eis_configvar "IP_NET_1_IPV4_STATIC_IP" "no"
	else
		{
		echo "iface eth0 inet static"
		echo "  address $PIPADDRESS"
		echo "  netmask $PNETMASK"
		echo "  gateway $PGATEWAY"
		echo "  hostname $PHOSTNAME"
		echo ""
		} >>/mnt/etc/network/interfaces
		{
		echo "search $PDOMAIN"
		for dns_server in $PDNSSERVER
		do
			echo "nameserver $dns_server"
		done
		} >/mnt/etc/resolv.conf
		set_eis_configvar "IP_NET_1_IPV4_STATIC_IP" "yes"
	fi
	echo "$PHOSTNAME" >/mnt/etc/hostname
	cat <<EOF >/mnt/etc/hosts
127.0.0.1 localhost
$PIPADDRESS $PHOSTNAME.$PDOMAIN $PHOSTNAME

# The following lines are desirable for IPv6 capable hosts
::1     ip6-localhost ip6-loopback
fe00::0 ip6-localnet
ff00::0 ip6-mcastprefix
ff02::1 ip6-allnodes
ff02::2 ip6-allrouters
ff02::3 ip6-allhosts

EOF
	set_eis_configvar "IP_NET_N" "1"
	set_eis_configvar "IP_NET_1_NAME" "eth0"
	set_eis_configvar "IP_NET_1_IPV4_IPADDR" "$PIPADDRESS"
	set_eis_configvar "IP_NET_1_IPV4_NETMASK" "$PNETMASK"
	set_eis_configvar "IP_NET_1_IPV4_GATEWAY" "$PGATEWAY"
	set_eis_configvar "HOSTNAME" "$PHOSTNAME"
	set_eis_configvar "DOMAIN_NAME" "$PDOMAIN"
	set_eis_configvar "DNS_SERVER" "$PDNSSERVER"
	rc_update networking boot
}


setup_timezone() {
	echo "$PTIMEZONE" >/mnt/etc/TZ
}


# setup
setup_root() {
	local root_dev="$1" boot_dev="$2"
	mkfs.$ROOTFS -q "$root_dev"
	mkdir -p /mnt
	mount -t $ROOTFS $root_dev /mnt || return 1
	if [ -n "$boot_dev" ]; then
		mkdir -p /mnt/boot
		mount -t $BOOTFS $boot_dev /mnt/boot || return 1
	fi

	setup_mdadm_conf
	install_mounted_root /mnt || return 1
	setup_keymap
	setup_network
	setup_timezone
	rc_update sshd default
	# change to bash login
	# bash not support UTF-8 ?
    #sed -i -e 's/\/ash$/\/bash/' /mnt/etc/passwd
	sed -i -e 's/^#\/bin\/bash/\/bin\/bash/' /mnt/etc/shells
	# set root password
	chroot /mnt /bin/bash -c "/bin/echo \"root:${PPASSWORD}\" | /usr/sbin/chpasswd 2>&1" 
	# remove bug files ?!
	rm -f /mnt/etc/runlevels/eis-install
	rm -f /mnt/etc/runlevels/default/eis-install
	# change /etc/motd
	{
	echo "Welcome to Alpine Linux with eisfair-ng!"
	echo ""
	echo "Please type 'setup' for administration."
	echo ""
	} > /mnt/etc/motd
	# change package repos
	{
	echo "http://dl-5.alpinelinux.org/alpine/v_RELVERS_/main"
	echo "http://download.eisfair.org/v_RELVERS_/main"
	} > /mnt/etc/apk/repositories
	unmount_partitions /mnt
	swapoff -a

	echo ""
	echo "Installation is complete. Please reboot."
}

native_disk_install_lvm() {
	local diskdev= vgname=vg0
	local lvm_part_type="8e"
	local boot_part_type="83"
	local boot_size=${BOOT_SIZE:-100}
	local lvm_size=
	local root_dev=/dev/$vgname/lv_root

	init_progs || return 1

	if [ -n "$USE_RAID" ]; then
		boot_part_type="fd"
		lvm_part_type="fd"
		stop_all_raid
	fi
	for diskdev in "$@"; do
		setup_partitions $diskdev \
			"$boot_size,$boot_part_type,*" \
			"$lvm_size,$lvm_part_type" || return 1
	done

	# will find BOOT_DEV for us
	setup_boot_dev $@

	setup_lvm_volume_group $vgname $@ || return 1
	setup_lvm_swap $vgname
	lvcreate --quiet -n ${root_dev##*/} -l 100%FREE $vgname
	rc-update add lvm boot
	setup_root $root_dev $BOOT_DEV
}

native_disk_install() {
	local root_part_type="83" swap_part_type="82" boot_part_type="83"
	local boot_size=${BOOT_SIZE:-100}
	local swap_size=${SWAP_SIZE}
	local root_size=
	local root_dev= boot_dev= swap_dev=

	init_progs || return 1

	if [ -n "$USE_RAID" ]; then
		boot_part_type="fd"
		root_part_type="fd"
		swap_part_type="fd"
		stop_all_raid
	fi
	for diskdev in "$@"; do
		dd if=/dev/zero of=${diskdev} bs=1k count=1 1>/dev/null 2>&1
		setup_partitions $diskdev \
			"$boot_size,$boot_part_type,*" \
			"$swap_size,$swap_part_type" \
			"$root_size,$root_part_type" \
			|| return 1
	done

	# will find BOOT_DEV for us
	setup_boot_dev $@
	
	if [ "$USE_RAID" ]; then
		[ $SWAP_SIZE -gt 0 ] && setup_non_boot_raid_dev /dev/md1 $@
		setup_non_boot_raid_dev /dev/md2 $@ || return 1
		swap_dev=/dev/md1
		root_dev=/dev/md2
	else
		swap_dev=$(find_nth_non_boot_parts 1 82 $@)
		root_dev=$(find_nth_non_boot_parts 1 83 $@)
	fi
	[ $SWAP_SIZE -gt 0 ] && setup_swap_dev $swap_dev
	setup_root $root_dev $BOOT_DEV
}

# ask for a root or data disk
# returns answer in global variable $answer
ask_disk() {
	local prompt="$1"
	local help_func="$2"
	local i=
	shift 2
	answer=
	local default_disk=${DEFAULT_DISK:-$1}

	while ! all_in_list "$answer" $@ "none" "abort"; do
		echo "Available disks are:"
		show_disk_info "$@"
		echon "$prompt [$default_disk] "
		default_read answer $default_disk
		case "$answer" in
			'abort') exit 0;;
			'none') return 0;;
			'?') $help_func;;
			*) for i in $answer; do
				if ! [ -b "/dev/$i" ]; then
					echo "/dev/$i is not a block device" >&2
					answer=
				   fi
			done;;
		esac
	done
}

usage() {
	cat <<__EOF__
usage: setup-disk [-hLqrv] [-k kernelflavor] [-m MODE] [-o apkovl] [-s SWAPSIZE]
		  [MOUNTPOINT | DISKDEV...]

Install alpine on harddisk.

If MOUNTPOINT is specified, then do a traditional disk install with MOUNTPOINT
as root.

If DISKDEV is specified, then use the specified disk(s) without asking. If
multiple disks are specified then set them up in a RAID array. If there are
mode than 2 disks, then use raid level 5 instead of raid level 1.

options:
 -h  Show this help
 -d  Use DHCP Client
 -D  Domain name
 -e  Keyboard variant
 -E  Keyboard layout
 -F  DNS-Server
 -G  Gateway
 -H  Host name
 -I  IP-Address
 -k  Use kernelflavor instead of $KERNEL_FLAVOR
 -L  Use LVM to manage partitions
 -N  Netmask
 -o  Restore system from given apkovl file
 -P  root password
 -q  Exit quietly if no disks are found
 -r  Enable software raid1 with single disk
 -s  Use SWAPSIZE MB instead of autodetecting swap size (Use 0 to disable swap)
 -T  Timezone
 -v  Be more verbose about what is happening

__EOF__
	exit 1
}


KERNEL_FLAVOR=grsec
case "$(uname -r)" in
	*-vs[0-9]*) KERNEL_FLAVOR=vserver;;
	*-pae) KERNEL_FLAVOR=pae;;
esac

USE_LVM=
# Parse args
while getopts "dD:e:E:F:G:H:I:hk:LN:o:P:qrs:T:v" opt; do
	case $opt in
		d) PNETIPSTATIC=0;;
		D) PDOMAIN="$OPTARG";;
		e) PKEYBVARIANT="$OPTARG";;
		E) PKEYBLAYOUT="$OPTARG";;
		F) PDNSSERVER="$OPTARG";;
		G) PGATEWAY="$OPTARG";;
		H) PHOSTNAME="$OPTARG";;
		I) PIPADDRESS="$OPTARG";;
		k) KERNEL_FLAVOR="$OPTARG";;
		L) USE_LVM="_lvm";;
		N) PNETMASK="$OPTARG";;
		o) APKOVL="$OPTARG";;
		P) PPASSWORD="$OPTARG";;
		q) QUIET=1;;
		r) USE_RAID=1;;
		s) SWAP_SIZE="$OPTARG";;
		T) PTIMEZONE="$OPTARG";;
		v) VERBOSE=1;;
		*) usage;;
	esac
done
shift $(( $OPTIND - 1))

swapoff -a >/dev/null 2>&1

# stop all volume groups in use
vgchange --ignorelockingfailure -a n >/dev/null 2>&1

if [ -n "$USE_RAID" ]; then
	stop_all_raid
fi

disks=$(find_disks)
diskdevs=

# no disks so lets exit quietly.
if [ -z "$disks" ]; then
	[ -z "$QUIET" ] && echo "No disks found." >&2
	exit 0
fi

if [ $# -gt 0 ]; then
	# check that they are 
	for i in "$@"; do
		j=$(readlink -f "$i" | sed 's:^/dev/::; s:/:!:g')
		if ! [ -e "/sys/block/$j/device" ]; then
			echo "$i is not a suitable for partitioning"
			exit 1
		fi
		diskdevs="$diskdevs /dev/$j"
	done
else
	echo "Missing disk! Which disk(s) would you like to use?"
fi

set -- $diskdevs
if [ $# -gt 1 ]; then
	USE_RAID=1
fi

dmesg -n1

# native disk install
native_disk_install$USE_LVM $diskdevs
